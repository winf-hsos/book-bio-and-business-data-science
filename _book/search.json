[
  {
    "objectID": "case-campusbier.html",
    "href": "case-campusbier.html",
    "title": "Fall: Campusbier",
    "section": "",
    "text": "Die Campusbier-Fallstudie ist in dem Sinne eine besondere Fallstudie im Rahmen dieses Buches, als dass sie als Einführung in das Basishandwerkszeug mit R dient. Wenn die Zeit für nur eine Fallstudie ausreicht und man Anfänger mit der Datenanalyse mit R ist, dann ist diese Fallstudie die richtige. Sie steht deshalb auch am Anfang des Buches und dient in allen meinen Modulen zur Datenanalyse mit R als Gegenstand der Einführung.\nDas Campusbier-Projekt beschäftigt sich mit der Vermarktung des hochschuleigenen Bieres, das 2009 von Studierenden auf der Versuchsbrauanlage der Hochschule Osnabrück entwickelt wurde. Im Jahr 2019 wurde das Bier erstmals in größerer Menge gebraut und in Flaschen abgefüllt, so dass es der Osnabrücker Bevölkerung zugänglich gemacht werden konnte. Zuvor war das Bier nur intern in Fässern erhältlich, die etwa für Veranstaltungen am Campus der Hochschule verwendet wurden. Die erste öffentliche Verkaufsrunde im Mai/Juni 2019 war ein voller Erfolg, was zu einer dauerhaften Verfügbarkeit des Bieres über den Onlie-Shop campusbier.de führte. Seitdem sind in vielen Projekten weitere Aktionen und Produkte hinzugekommen, deren Verkäufe sich im vorliegenden Datensatz wiederspiegeln."
  },
  {
    "objectID": "case-campusbier.html#der-datensatz",
    "href": "case-campusbier.html#der-datensatz",
    "title": "Fall: Campusbier",
    "section": "Der Datensatz",
    "text": "Der Datensatz\nDer Datensatz besteht aus den Informationen zu den knapp 3000 Bestellungen, die in den Jahren 2019 bis 2022 über den Online-Shop aufgegeben wurden. Neben den Metadaten einer Bestellung, wie der Bestellzeitpunkt, der Kunde oder die Zahlungsart, gibt es auch die Informationen über die gekauften Produkte, also den Warenkorb jeder Bestellung. Diese Daten liegen als CSV-Exporte aus dem E-Commerce-System Shopify vor. Der Datensatz besteht aus den beiden Dateien orders.csv und line_items.csv. Um dem Datenschutz Rechnung zu tragen, wurden sämtliche persönliche Daten der Kunden entfernt. Jeder Kunde ist nur über eine technische Nummer identifizierbar, die in jeder Bestellung angegeben ist. Haben mehrere Bestellungen die gleiche Kundennummer, so stammen diese alle vom selben Kunden.\n\n\n\n\n\n\nLadet euch am besten jetzt die beiden Dateien in euer Arbeitsverzeichnis herunter. Hier die Links zum Download (rechte Maustaste, “Link speichern unter”):\n\norders.csv\nline_items.csv"
  },
  {
    "objectID": "read-csv-files.html",
    "href": "read-csv-files.html",
    "title": "\n1  CSV-Dateien einlesen\n",
    "section": "",
    "text": "Im ersten Schritt jeder Datenanalyse müssen wir unserem Computer den Datensatz zur Verfügung stellen. Wir sprechen dabei auch vom Laden des Datesatzes. Dabei sagen wir dem Computer, wo die Daten zu finden sind und dass er sie für den schnelleren Zugriff in seinen Arbeitsspeicher holen soll.\nDaten liegen in den meisten Fällen in Form von Dateien vor. In manchen Fällen sind sie auch in einer Datenbank gespeichert. Im Fall einer Datei kann ein Datensatz in unterschiedlichen Formaten darin gespeichert werden. Ein gängiges Format ist das CSV-Format, das auf einfachen Textdateien basiert."
  },
  {
    "objectID": "read-csv-files.html#das-csv-format",
    "href": "read-csv-files.html#das-csv-format",
    "title": "\n1  CSV-Dateien einlesen\n",
    "section": "\n1.1 Das CSV-Format",
    "text": "1.1 Das CSV-Format\nCSV als weit verbreitetes Format\nFür die Speicherung von Daten bieten sich textuelle Formate an, weil sie auf jedem Betriebsystem mit einem einfachen Texteditor betrachtet und bearbeitet werden können. Das ermöglicht das einfache Teilen von Daten und somit die Zusammenarbeit. Auch für den Datenaustausch zwischen verschiedenen Informationssystemen wird häufig ein textbasiertes Format verwendet, um spezifisches Formate der jeweiligen Hersteller, wie etwa proprieäte Datenbanken, zu überbrücken. Deshalb bieten die meisten Informationssysteme Schnittstellen für den Export und Import von Textdateien an. Speziell das CSV-Format ist hier sehr beliebt, aus guten Gründen:\n\nDie Verwendung von einfachen Textdateien erlaubt die Speicherung und Verarbeitung auf unterschiedlichen Umgebungen wie Windows, macOS oder Linux.\nDas Format ist einfach zu verstehen und auch für Menschen lesbar.\nCSV ist ein offenes Format, d. h. es gibt keine Organisation, die daran die Rechte besitzt und es kann daher von jeder Software verwendet werden. Es gab lange nicht einmal eine offizielle Spezifikation des Formats. Mittlerweile gibt es eine Spezifikation als offizieller MIME Type.\n\nAuch das E-Commerce-System Shopify, aus dem die vorligenden Verkaufsdaten stammen, bietet eine Möglichkeit zum Exportieren von Textdateien im sogenannten CSV-Format an.\nCSV eignet sich für strukturierte Daten\nCSV steht für Comma Separated Values und beschreibt ein Format, um strukturierte Daten in einer Textdatei abzuspeichern. Ihr erkennt eine Textdatei im CSV-Format an der Endung .csv.\nDas CSV-Format basiert auf einfachen Textkodierungen, häufig im UTF-8 oder ASCII-Kodierungssystem (letzeres immer seltener wegen der geringen Anzahl verfügbarer Zeichen), die mit fast jedem Werkzeug und Editor gelesen und bearbeitet werden können. Zusätzlich bildet das CSV-Format eine tabellarische Struktur ab, bei dem die Daten in Zeilen und Spalten getrennt werden. Alle darauf folgenden Zeilen stellen Beobachtungen oder Datensätze dar, deren Variablenwerte mit dem gleichen Trennzeichen abgegrenzt werden.\nDas CSV-Format speichert strukturierte Daten in einer tabellarischen Form, ähnlich wie in Spreadsheets. Die erste Zeile einer CSV-Datei ist üblicherweise der sogenannte Header (Kopfzeile) und beinhaltet die Spaltennamen mit Kommata oder Semikolon (Trennzeichen) voneinander getrennt. Jede weitere Zeile stellt eine Beobachtung (Englisch: observation oder case) oder auch Datensatz (Englisch: record) dar. Jeder Datensatz enthält für die im Header definierten Attribute (oder Spalten) einen Wert, die durch das gleiche Trennzeichen voneinander getrennt sind. Es muss nicht jeder Spaltenwert existieren. Sollte ein Wert für eine Beobachtung nicht vorhanden sein, so wird einfach nach dem Komma nichts eingetragen und es folgen zwei Kommata nacheinander. In R werden fehlende Werte mit NA gekennzeichnet.\nDie Verwendung des Komma als Trennzeichen in CSV-Dateien ist keineswegs verbindlich, auch wenn es Bestandteil des Namens ist. Generell kann jedes Symbol verwendet werden. Häufige Alternativen sind das Semikolon, Leerzeichen oder ein Tabstop. Letzteres wird oft mit der eigenen Endung .tsv für Tab Separated Values gespeichert.\nBeispiel einer CSV-Datei\nDer Auschnitt unten zeigt die ersten vier Zeilen der orders.csv. Die erste Zeile enthält die Namen der hier gezeigten vier Spalten (der Datensatz hat mehr Spalten, das ist nur ein Auszug), die mit einem Komma voneinander getrennt sind. Darunter folgen drei beispielhafte Datensätze:\nid,order_id,name,order_number,app_id,created_at\n1130007101519,B1014,1014,580111,2019-05-24T14:59:16+02:00\n1130014965839,B1015,1015,580111,2019-05-24T15:09:08+02:00\n1130026958927,B1016,1016,580111,2019-05-24T15:22:41+02:00\n..."
  },
  {
    "objectID": "read-csv-files.html#csv-daten-laden-mit-readr",
    "href": "read-csv-files.html#csv-daten-laden-mit-readr",
    "title": "\n1  CSV-Dateien einlesen\n",
    "section": "\n1.2 CSV-Daten laden mit {readr}\n",
    "text": "1.2 CSV-Daten laden mit {readr}\n\nAus einer lokalen Datei\nFür das Laden von Datensätzen aus CSV-Dateien bietet das Tidyverse ein Paket namens readr an. Dieses wird automatisch mit dem tidyverse-Paket mitgeladen. Das Paket bietet für CSV-Dateien, bei denen das Komma als Trennzeichen verwendet wird, die Funktion read_csv an:\n\norders <- read_csv(\"./data/orders.csv\")\n\n\n\n\n\n\n\nIn einigen Ländern Europas wird häufig ein Semikolon als Trennzeichen und ein Komma als Dezimaltrennzeichen verwendet (wie etwa in Deutschland). Für diesen Fall bietet readr die Funktion read_csv2. Um es selbst in der Hand zu haben, kann die Funktion read_delim verwendet werden und über den Parameter delim das Trennzeichen manuell eingestellt werden.\n\n\n\nAuch der R-Basisumfang bietet eine ähnliche Funktion für genau diesen Anwendungsfall an. Diese heisst read.csv, man achte hier auf das Detail: Statt eines Unterstrichs _ wird bei der R-Basisfunktion ein Punkt . zwischen den beiden Wörtern read und csv verwendet. Wenn ihr mit dem Tidyverse und mit Tibbles arbeitet (wie in diesem Buch durchgängig), dann achtet darauf, stets die readr-Funktion read_csv zu verwenden, weil nur diese die Daten als Tibble zurückgibt und zudem einige paar nützliche Zusatzfunktionen bietet.\nNur bestimmte Spalten laden\nDie read_csv-Funktion erlaubt direkt beim Laden der Daten eine Auswahl der Spalten vorzunehmen. Ich empfehle hier immer die Verwendung der select-Funktion, die wir im nächsten Abschnitt kennenlernen werden. Dennoch möchte ich kurz demonstrieren, wie das Filtern der Spalten beim Laden funktioniert.\nDer folgende Code lädt die Spalten order_id, name, sowie alle Spalten, deren Name mit “customer” beginnen:\n\norders <- read_csv(\"./data/orders.csv\", col_select = c(order_id, name, starts_with(\"customer\")))\n\nIm Ergebnis ist der resultierende Tibble dann sehr viel schmaler und beinhaltet nur die gewünschten Spalten:\n\ncolnames(orders)\n\n [1] \"order_id\"                             \n [2] \"name\"                                 \n [3] \"customer_id\"                          \n [4] \"customer_accepts_marketing\"           \n [5] \"customer_accepts_marketing_updated_at\"\n [6] \"customer_marketing_opt_in_level\"      \n [7] \"customer_sms_marketing_consent\"       \n [8] \"customer_created_at\"                  \n [9] \"customer_updated_at\"                  \n[10] \"customer_gender\"                      \n[11] \"customer_is_hsos\"                     \n[12] \"customer_state\"                       \n[13] \"customer_orders_count\"                \n[14] \"customer_total_spent\"                 \n[15] \"customer_last_order_id\"               \n[16] \"customer_note\"                        \n[17] \"customer_verified_email\"              \n[18] \"customer_tax_exempt\"                  \n[19] \"customer_tags\"                        \n[20] \"customer_last_order_name\"             \n\n\nHat man nur eine Filterbedingung, so kann man sich die c()-Funktion auch sparen:\n\norders <- read_csv(\"./data/orders.csv\", col_select = starts_with(\"shipping\"))\n\nDas Ergebnis:\n\ncolnames(orders)\n\n[1] \"shipping_address_city\"      \"shipping_address_zip\"      \n[3] \"shipping_address_country\"   \"shipping_address_latitude\" \n[5] \"shipping_address_longitude\"\n\n\nIst man auf möglichst wenige Zeilen Code aus, so kann die Verwendung des col_types-Parameters durchaus Sinn ergeben. Man könnte den gleichen Effekt auch mit einem anschließenden select erzielen:\n\norders <- read_csv(\"./data/orders.csv\") %>% \n  select(starts_with(\"shipping\"))\n\nMehr zur Auswahl von Spalten mit dplyr erfahrt ihr in Kapitel 3.\nDas Dezimaltrennzeichen bestimmen\nWollen wir nur das Dezimaltrennzeichen ändern, weil wir zum Beispiel Daten aus einem deutschen System exportiert haben, das ein Komma verwendet, so können wir das über den locale-Parameter erreichen. Im Beispiel unten verwenden wir zusätzlich das Pipe-Symbol | als Trennzeichen. Beides können wir über read_delim einstellen:\n\n# Daten in sales.csv\n# year,month,turnover\n# 2022|01|2700,85\n# 2022|02|2910,10\n# 2022|03|1802,37\n\nturnover <- read_delim(\"sales.csv\", \n                       delim = \"|\", \n                       locale = locale(decimal_mark = \",\")\n                       )\n\nDas Ergebnis:\n\nturnover\n\n# A tibble: 3 x 3\n   year month turnover\n  <dbl> <chr>    <dbl>\n1  2022 01       2701.\n2  2022 02       2910.\n3  2022 03       1802.\n\n\nDatentypen beim Laden setzen\nBeim Laden mit read_csv wird möglicherweise der Datentyp einiger Spalten falsch erkannt. DIe Funktion betrachtet die ersten Zeilen und ermittelt darauf basierend den Datentyp. Wird dieser falsch erkannt, so können den Datentyp für Spalten explizit angeben. Wie auch das Auswählen von Spalten können wir den Datentyp schon beim Laden mit. Alternativ können wir den Datentypen auch später mit mutate noch verändern.\n\n\n\n\n\n\nManchmal hilft es schon, den Parameter guess_max auf einen größeren Wert zu setzen. Dieser bestimmt, wie viele Werte die Funktion betrachtet, um daraus den Datentyp einer Spalte abzuleiten. Standardmäßig ist dieser Wert auf 1000 begrenzt.\n\n\n\nIn unserem Datensatz orders.csv sind tatsächlich einige Datentypen falsch erkannt worden. Etwa die Spalte order_id, die als Datentyp double erkannt wird. Auch wenn die Werte allesamt als Dezimalzahlen betrachtet werden können, handelt es sich bei einer Bestellnummer nicht um eine Zahl in dem Sinne, dass man damit rechnen möchte. Es ist vielmehr eine Zeichenfolge, die per Konvention nur aus Zahlen besteht (aber nicht müsste). Der Datentyp character wäre somit angebrachter. Das können wir wie folgt ändern:\n\norders <- read_csv(\"./data/orders.csv\",\n                   col_types = list(\"order_id\" = col_character()))\n\n# Die Spalte order_id ist jetzt vom Typ <chr>\norders %>% \n  select(order_id)\n\n# A tibble: 2,874 x 1\n   order_id     \n   <chr>        \n 1 1130007101519\n 2 1130014965839\n 3 1130026958927\n 4 1130030563407\n 5 1130038853711\n 6 1130045964367\n 7 1130050519119\n 8 1130060283983\n 9 1130102194255\n10 1130106880079\n# ... with 2,864 more rows\n\n\nDas Gleiche können wir mit beliebig vielen Spalten gleichzeitig durchführen:\n\norders <- read_csv(\"./data/orders.csv\",\n                   col_types = list(\n                     \"order_id\" = col_character(),\n                     \"app_id\" = col_character()\n                     )\n                   )\n\n# Die Spalte order_id ist jetzt vom Typ <chr>\norders %>% \n  select(order_id, app_id)\n\n# A tibble: 2,874 x 2\n   order_id      app_id\n   <chr>         <chr> \n 1 1130007101519 580111\n 2 1130014965839 580111\n 3 1130026958927 580111\n 4 1130030563407 580111\n 5 1130038853711 580111\n 6 1130045964367 580111\n 7 1130050519119 580111\n 8 1130060283983 580111\n 9 1130102194255 580111\n10 1130106880079 580111\n# ... with 2,864 more rows\n\n\nDaten von einem Webserver laden\nDie CSV-Datei muss nicht lokal auf dem eigenen Rechner vorliegen, sondern kann mit read_csv über das HTTP-Protkoll direkt von einem Webserver im Internet abgerufen werden. Dabei wird die URL anstelle des lokalen Dateinamens der Funktion übergeben. Der Code unten lädt die tagesaktuelle Version des Covid-19-Datensatzes, der auf den Servern von Our World in Data gehostet wird:\n\ncovid <- read_csv(\"https://covid.ourworldindata.org/data/owid-covid-data.csv\")\n\nRows: 220105 Columns: 67\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr   (4): iso_code, continent, location, tests_units\ndbl  (62): total_cases, new_cases, new_cases_smoothed, total_deaths, new_dea...\ndate  (1): date\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "explore-new-data-sets.html",
    "href": "explore-new-data-sets.html",
    "title": "\n2  Datensätze erkunden\n",
    "section": "",
    "text": "Alleine beim Aufruf seines Namens gibt ein Tibble in der Konsole viele seiner Informationen preis:\n\norders\n\n# A tibble: 2,874 x 68\n     order_id name  order~1 app_id created_at          updated_at          test \n        <dbl> <chr>   <dbl>  <dbl> <dttm>              <dttm>              <lgl>\n 1    1.13e12 B1014    1014 580111 2019-05-24 12:59:16 2019-06-19 13:23:26 FALSE\n 2    1.13e12 B1015    1015 580111 2019-05-24 13:09:08 2019-06-21 14:40:07 FALSE\n 3    1.13e12 B1016    1016 580111 2019-05-24 13:22:41 2019-06-21 12:35:23 FALSE\n 4    1.13e12 B1017    1017 580111 2019-05-24 13:27:43 2019-06-21 14:27:18 FALSE\n 5    1.13e12 B1018    1018 580111 2019-05-24 13:36:46 2019-06-21 12:11:57 FALSE\n 6    1.13e12 B1019    1019 580111 2019-05-24 13:44:41 2019-06-21 14:37:21 FALSE\n 7    1.13e12 B1020    1020 580111 2019-05-24 13:49:21 2019-06-21 12:25:16 FALSE\n 8    1.13e12 B1021    1021 580111 2019-05-24 13:59:57 2019-06-21 11:49:47 FALSE\n 9    1.13e12 B1022    1022 580111 2019-05-24 14:43:53 2019-06-19 14:12:38 FALSE\n10    1.13e12 B1023    1023 580111 2019-05-24 14:48:16 2019-06-21 15:54:24 FALSE\n# ... with 2,864 more rows, 61 more variables: current_subtotal_price <dbl>,\n#   current_total_price <dbl>, current_total_discounts <dbl>,\n#   current_total_duties_set <dbl>, total_discounts <dbl>,\n#   total_line_items_price <dbl>, total_outstanding <dbl>, total_price <dbl>,\n#   total_tax <dbl>, total_tip_received <dbl>, taxes_included <lgl>,\n#   discount_codes <chr>, financial_status <chr>, fulfillment_status <chr>,\n#   source_name <chr>, landing_site <chr>, landing_site_ref <chr>, ...\n\n\nNeben den ersten paar Zeilen als Vorschau gibt ein Tibble auch die Gesamtzahl an Zeilen und Spalten aus. Hier sind es 2874 Zeilen und 68 Spalten. Darunter folgt eine mit Kommata getrennte Auflistung der Spaltennamen und ihren Datentypen. Diese Liste wird aber nach wenigen Zeilen abgebrochen, um die Konsole nicht mit Text zu überladen.\n\n\n\n\n\n\nVersucht das einmal: Ladet die CSV-Datei statt mit read_csv mit der Funktion read.csv aus dem Basis-R. Gebt jetzt den Namen des Dataframes in die Konsole ein und drückt Enter. Was ist der Unterschied bei der Ausgabe? Was gefällt euch besser?"
  },
  {
    "objectID": "explore-new-data-sets.html#spalten-und-deren-datentypen",
    "href": "explore-new-data-sets.html#spalten-und-deren-datentypen",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.3 Spalten und deren Datentypen",
    "text": "2.3 Spalten und deren Datentypen\nDie schnellste und, wie ich finde, einfachste Möglichkeit, einen Überblick über die Datentypen in einem Tibble zu erhalten, ist die glimpse-Funktion:\n\norders %>% \n  glimpse()\n\nRows: 2,874\nColumns: 68\n$ order_id                              <dbl> 1.130007e+12, 1.130015e+12, 1.13~\n$ name                                  <chr> \"B1014\", \"B1015\", \"B1016\", \"B101~\n$ order_number                          <dbl> 1014, 1015, 1016, 1017, 1018, 10~\n$ app_id                                <dbl> 580111, 580111, 580111, 580111, ~\n$ created_at                            <dttm> 2019-05-24 12:59:16, 2019-05-24~\n$ updated_at                            <dttm> 2019-06-19 13:23:26, 2019-06-21~\n$ test                                  <lgl> FALSE, FALSE, FALSE, FALSE, FALS~\n$ current_subtotal_price                <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ current_total_price                   <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ current_total_discounts               <dbl> 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0,~\n$ current_total_duties_set              <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_discounts                       <dbl> 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0,~\n$ total_line_items_price                <dbl> 96.66, 32.22, 32.22, 32.22, 32.2~\n$ total_outstanding                     <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_price                           <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ total_tax                             <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_tip_received                    <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ taxes_included                        <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TR~\n$ discount_codes                        <chr> \"DCBPXGJB1JGA\", NA, \"KY0D5MNEZBM~\n$ financial_status                      <chr> \"paid\", \"paid\", \"paid\", \"paid\", ~\n$ fulfillment_status                    <chr> \"fulfilled\", \"fulfilled\", \"fulfi~\n$ source_name                           <chr> \"web\", \"web\", \"web\", \"web\", \"web~\n$ landing_site                          <chr> \"/password\", \"/wallets/checkouts~\n$ landing_site_ref                      <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ location_id                           <dbl> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ note                                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ tags                                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ processed_at                          <dttm> 2019-05-24 12:59:15, 2019-05-24~\n$ processing_method                     <chr> \"direct\", \"express\", \"express\", ~\n$ payment_details_gateway               <chr> \"shopify_payments\", \"paypal\", \"p~\n$ payment_details_credit_card_company   <chr> \"Mastercard\", NA, NA, NA, NA, NA~\n$ customer_id                           <dbl> 1.861678e+12, 1.856892e+12, 1.87~\n$ customer_accepts_marketing            <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~\n$ customer_accepts_marketing_updated_at <dttm> 2019-05-21 13:38:54, 2019-05-24~\n$ customer_marketing_opt_in_level       <chr> \"single_opt_in\", \"single_opt_in\"~\n$ customer_sms_marketing_consent        <lgl> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ customer_created_at                   <dttm> 2019-05-13 14:41:16, 2019-05-10~\n$ customer_updated_at                   <dttm> 2022-02-23 13:50:50, 2022-06-21~\n$ customer_gender                       <chr> \"f\", \"m\", \"m\", \"m\", \"f\", \"m\", \"m~\n$ customer_is_hsos                      <dbl> 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0,~\n$ customer_state                        <chr> \"disabled\", \"disabled\", \"enabled~\n$ customer_orders_count                 <dbl> 7, 10, 3, 1, 2, 1, 1, 1, 3, 6, 1~\n$ customer_total_spent                  <dbl> 345.22, 338.40, 95.17, 32.22, 66~\n$ customer_last_order_id                <dbl> 4.640512e+12, 5.053779e+12, 1.95~\n$ customer_note                         <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ customer_verified_email               <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~\n$ customer_tax_exempt                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ customer_tags                         <chr> \"password page, prospect, umfrag~\n$ customer_last_order_name              <chr> \"41005353622\", \"41005379922\", \"1~\n$ campaign_tag                          <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ shipping_address_city                 <chr> NA, \"Osnabrück\", NA, NA, NA, NA,~\n$ shipping_address_zip                  <dbl> NA, 49088, NA, NA, NA, NA, 49090~\n$ shipping_address_country              <chr> NA, \"Germany\", NA, NA, NA, NA, \"~\n$ shipping_address_latitude             <dbl> NA, 52.29756, NA, NA, NA, NA, 52~\n$ shipping_address_longitude            <dbl> NA, 8.058480, NA, NA, NA, NA, 8.~\n$ billing_address_city                  <chr> \"Quakenbrück\", \"Osnabrück\", \"Osn~\n$ billing_address_zip                   <dbl> 49610, 49088, 49080, 45888, 4935~\n$ billing_address_country               <chr> \"Germany\", \"Germany\", \"Germany\",~\n$ billing_address_company               <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ billing_address_latitude              <dbl> 52.67033, 52.29756, 52.26469, 51~\n$ billing_address_longitude             <dbl> 7.959575, 8.058480, 8.035603, 7.~\n$ client_details_browser_ip             <chr> \"131.173.97.189\", \"131.173.96.36~\n$ client_details_browser_height         <dbl> 665, 1010, 657, 600, 560, 553, 5~\n$ client_details_browser_width          <dbl> 1263, 2048, 1349, 360, 360, 375,~\n$ client_details_user_agent             <chr> \"Mozilla/5.0 (Windows NT 10.0; W~\n$ cancel_reason                         <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ cancelled_at                          <dttm> NA, NA, NA, NA, NA, NA, NA, NA,~\n$ closed_at                             <dttm> 2019-06-19 13:23:26, 2019-06-21~\n\n\nNeben dem Namen der Spalten erhalten wir den Datentyp sowie eine Vorschau der ersten in jeder Spalte enthaltenen Werte. Auch die Anzahl Zeilen und Spalten nennt uns glimpse.\nEtwas technischer geht es mit der spec-Funktion. Diese liefert statt des Datentyp-Kürzels auch gleich die genaue Spezfikation als R-Funktion zurück:\n\nspec(orders)\n\ncols(\n  order_id = col_double(),\n  name = col_character(),\n  order_number = col_double(),\n  app_id = col_double(),\n  created_at = col_datetime(format = \"\"),\n  updated_at = col_datetime(format = \"\"),\n  test = col_logical(),\n  current_subtotal_price = col_double(),\n  current_total_price = col_double(),\n  current_total_discounts = col_double(),\n  current_total_duties_set = col_double(),\n  total_discounts = col_double(),\n  total_line_items_price = col_double(),\n  total_outstanding = col_double(),\n  total_price = col_double(),\n  total_tax = col_double(),\n  total_tip_received = col_double(),\n  taxes_included = col_logical(),\n  discount_codes = col_character(),\n  financial_status = col_character(),\n  fulfillment_status = col_character(),\n  source_name = col_character(),\n  landing_site = col_character(),\n  landing_site_ref = col_character(),\n  location_id = col_double(),\n  note = col_character(),\n  tags = col_character(),\n  processed_at = col_datetime(format = \"\"),\n  processing_method = col_character(),\n  payment_details_gateway = col_character(),\n  payment_details_credit_card_company = col_character(),\n  customer_id = col_double(),\n  customer_accepts_marketing = col_double(),\n  customer_accepts_marketing_updated_at = col_datetime(format = \"\"),\n  customer_marketing_opt_in_level = col_character(),\n  customer_sms_marketing_consent = col_logical(),\n  customer_created_at = col_datetime(format = \"\"),\n  customer_updated_at = col_datetime(format = \"\"),\n  customer_gender = col_character(),\n  customer_is_hsos = col_double(),\n  customer_state = col_character(),\n  customer_orders_count = col_double(),\n  customer_total_spent = col_double(),\n  customer_last_order_id = col_double(),\n  customer_note = col_character(),\n  customer_verified_email = col_double(),\n  customer_tax_exempt = col_double(),\n  customer_tags = col_character(),\n  customer_last_order_name = col_character(),\n  campaign_tag = col_character(),\n  shipping_address_city = col_character(),\n  shipping_address_zip = col_double(),\n  shipping_address_country = col_character(),\n  shipping_address_latitude = col_double(),\n  shipping_address_longitude = col_double(),\n  billing_address_city = col_character(),\n  billing_address_zip = col_double(),\n  billing_address_country = col_character(),\n  billing_address_company = col_character(),\n  billing_address_latitude = col_double(),\n  billing_address_longitude = col_double(),\n  client_details_browser_ip = col_character(),\n  client_details_browser_height = col_double(),\n  client_details_browser_width = col_double(),\n  client_details_user_agent = col_character(),\n  cancel_reason = col_character(),\n  cancelled_at = col_datetime(format = \"\"),\n  closed_at = col_datetime(format = \"\")\n)\n\n\nFällt uns auf, dass ein Datentyp falsch erkannt wurde, so können wir entweder unseren Ladevorgang anpassen und etwa den Datentyp direkt beim Lesen korrigieren. Alternativ verändern wir die Spalte mit mutate, was wir in Kapitel 4 lernen werden."
  },
  {
    "objectID": "explore-new-data-sets.html#häufigkeiten-schnell-erfassen",
    "href": "explore-new-data-sets.html#häufigkeiten-schnell-erfassen",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.3 Häufigkeiten schnell erfassen",
    "text": "2.3 Häufigkeiten schnell erfassen\nMit dem bereits bekannten janitor-Paket erhalten wir eine Funktion, um für nominal skalierte Merkmale schnell die Häufigkeiten, sowohl absolut als auch prozentual, zu ermitteln:\n\nlibrary(janitor)\n\norders %>% \n  tabyl(payment_details_gateway)\n\n# A tibble: 4 x 4\n  payment_details_gateway     n  percent valid_percent\n  <chr>                   <int>    <dbl>         <dbl>\n1 manual                    194 0.0675          0.0675\n2 paypal                   1790 0.623           0.623 \n3 shopify_payments          889 0.309           0.309 \n4 <NA>                        1 0.000348       NA     \n\n\nWenn wir eine zweite Variable hinzufügen, so erstellt tabyl eine Kreuztabelle mit den absoluten Häufigkeiten der jeweiligen Kombinationen:\n\norders %>% \n  tabyl(payment_details_gateway, payment_details_credit_card_company)\n\n# A tibble: 4 x 5\n  payment_details_gateway `American Express` Mastercard  Visa   NA_\n  <chr>                                <dbl>      <dbl> <dbl> <dbl>\n1 manual                                   0          0     0   194\n2 paypal                                   0          1     3  1786\n3 shopify_payments                        14        372   303   200\n4 <NA>                                     0          0     0     1\n\n\nWir können so erkennen, dass für PayPal-Zahlungen nur sehr selten ein Kreditkartenanbieter hinterlegt ist. Bei den Shopify-Payments hingegen ist das in den meisten Bestellungen der Fall. Dabei liegt Mastercard knapp vor Visa, American Express ist eher die Ausnahme.\n\n\n\n\n\n\nEs wäre doch interessant zu wissen, warum genau eine Bestellung keine Angabe zur Zahlungsart besitzt. Prüft doch mal nach, welche das ist und versucht die Frage zu beantworten."
  },
  {
    "objectID": "read-csv-files.html#übungsaufgaben",
    "href": "read-csv-files.html#übungsaufgaben",
    "title": "\n1  CSV-Dateien einlesen\n",
    "section": "Übungsaufgaben",
    "text": "Übungsaufgaben\n\nLadet den tagesaktuellen Datensatz für die Covid-Daten, lasst aber nur die Spalten date, location und new_cases_smoothed_per_million im Ergebnis!"
  },
  {
    "objectID": "explore-new-data-sets.html#übungsaufgaben",
    "href": "explore-new-data-sets.html#übungsaufgaben",
    "title": "\n2  Datensätze erkunden\n",
    "section": "Übungsaufgaben",
    "text": "Übungsaufgaben\nSpeichert die Lösungen für die folgenden Aufgaben in einem neuen R-Skript. Vergesst nicht, die Datei zwischendurch zu speichern.\n\n\nDimensionen ermitteln\n\nErmittelt die Anzahl Spalten und Zeilen des Datensatzes. Ihr werdet herausfinden, dass es dafür verschiedene Möglichkeiten gibt.\nFindet auch eine Möglichkeit, mit der ihr beide Größen auf jeweils einer Variable speichern könnt. Das kann zum Beispiel wichtig sein, wenn ihr mit den Größen im weiteren Skriptverlauf weiter arbeiten wollt.\n\n\n\nNützliche Funktionen\n\n\nRecherchiert und testet die folgenden Funktionen. Notiert euch in eigenen Worten, was jede Funktion zurückgibt:\n\nhead()\ntail()\nprint()\nsample_n()\nglimpse()\nsummary()\ncolnames()\n\n\nWelche Parameter könnt ihr den Funktionen jeweils übergeben und wozu dienen sie?\nWozu würdet ihr die Funktionen verwenden?\n\n\n\nDatentypen ermitteln\n\nFindet einen Weg, um den Datentyp für jede Spalte auf der Konsole auszugeben!\nWelche Datentypen sind vertreten?\nSind eurer Meinung nach alle Spalten korrekt erkannt worden?\n\n\n\nDas Paket skimr\n\nInstalliert das Paket skimr und betrachtet nun die Funktion skim().\nWas ermittelt die Funktion, wenn wir ihr einen Datensatz übergeben?\nGebt mithilfe der Funktion nur den prozentualen Anteil fehlender Werte (NA) für jede Spalte auf der Konsole aus!"
  },
  {
    "objectID": "explore-new-data-sets.html#anzahl-spalten-und-zeilen-ermitteln",
    "href": "explore-new-data-sets.html#anzahl-spalten-und-zeilen-ermitteln",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.2 Anzahl Spalten und Zeilen ermitteln",
    "text": "2.2 Anzahl Spalten und Zeilen ermitteln\nEin Tibble gibt es uns freiwillig Auskunft über seine Dimensionierung, wenn wir seinen Namen aufrufen. Wir können diese Werte auch dediziert ermitteln, falls wir mit diesen Information etwa weitere Berechnungen in unserem Skript durchführen wollen.\nMit ncol erhalten wir die Anzahl Spalten:\n\norders %>% \n  ncol()\n\n[1] 68\n\n\nMit nrow entsprechend die Anzahl Zeilen:\n\norders %>% \n  nrow()\n\n[1] 2874\n\n\nWir könnten mit beiden Werten die Anzahl Zellen errechnen:\n\ncols <- ncol(orders)\nrows <- nrow(orders)\ncells <- cols * rows\ncells\n\n[1] 195432\n\n\nMit der Funktion dim erhalten wir einen Vektor mit beiden Informationen:\n\norders %>% \n  dim()\n\n[1] 2874   68\n\n\nDer erste Wert steht für die Anzahl Zeilen, der zweite für die Spalten.\nWenn wir als Ergebnis statt eines Vektors lieber ein Tibble hätten, können wir uns für für die Anzahl Zeilen mit count helfen:\n\norders %>% \n  count()\n\n# A tibble: 1 x 1\n      n\n  <int>\n1  2874\n\n\nWir können auch nrow und ncol als Spalten in einen neuen Dataframe (Tibble) verwenden und darauf basierend eine weitere, berechnete Spalte erstellen:\n\ntibble(\n  number_cols = ncol(orders), \n  number_rows = nrow(orders),\n  number_cells = number_cols * number_rows\n  )\n\n# A tibble: 1 x 3\n  number_cols number_rows number_cells\n        <int>       <int>        <int>\n1          68        2874       195432"
  },
  {
    "objectID": "explore-new-data-sets.html#häufigkeiten-erfassen",
    "href": "explore-new-data-sets.html#häufigkeiten-erfassen",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.6 Häufigkeiten erfassen",
    "text": "2.6 Häufigkeiten erfassen\nWir haben oben bereits count für das Zählen der Zeilen kennengelernt. Die Funktion eignet sich auch für das Zählen von Zeilen gruppiert nach einem Merkmal in den Daten:\n\norders %>% \n  count(payment_details_gateway)\n\n# A tibble: 4 x 2\n  payment_details_gateway     n\n  <chr>                   <int>\n1 manual                    194\n2 paypal                   1790\n3 shopify_payments          889\n4 <NA>                        1\n\n\nDas geht auch sortiert nach Häufigkeit:\n\norders %>% \n  count(payment_details_gateway, sort = TRUE)\n\n# A tibble: 4 x 2\n  payment_details_gateway     n\n  <chr>                   <int>\n1 paypal                   1790\n2 shopify_payments          889\n3 manual                    194\n4 <NA>                        1\n\n\nMit dem bereits bekannten janitor-Paket erhalten wir eine Funktion, um für nominal skalierte Merkmale schnell die Häufigkeiten, sowohl absolut als auch prozentual, zu ermitteln:\n\nlibrary(janitor)\n\norders %>% \n  tabyl(payment_details_gateway)\n\n# A tibble: 4 x 4\n  payment_details_gateway     n  percent valid_percent\n  <chr>                   <int>    <dbl>         <dbl>\n1 manual                    194 0.0675          0.0675\n2 paypal                   1790 0.623           0.623 \n3 shopify_payments          889 0.309           0.309 \n4 <NA>                        1 0.000348       NA     \n\n\nHier müssen wir das Sortieren manuelle mit arrange vornehmen:\n\norders %>% \n  tabyl(payment_details_gateway) %>% \n  arrange(-n)\n\n# A tibble: 4 x 4\n  payment_details_gateway     n  percent valid_percent\n  <chr>                   <int>    <dbl>         <dbl>\n1 paypal                   1790 0.623           0.623 \n2 shopify_payments          889 0.309           0.309 \n3 manual                    194 0.0675          0.0675\n4 <NA>                        1 0.000348       NA     \n\n\nWenn wir eine zweite Variable hinzufügen, so erstellt tabyl eine Kreuztabelle mit den absoluten Häufigkeiten der jeweiligen Kombinationen:\n\norders %>% \n  tabyl(payment_details_gateway, payment_details_credit_card_company)\n\n# A tibble: 4 x 5\n  payment_details_gateway `American Express` Mastercard  Visa   NA_\n  <chr>                                <dbl>      <dbl> <dbl> <dbl>\n1 manual                                   0          0     0   194\n2 paypal                                   0          1     3  1786\n3 shopify_payments                        14        372   303   200\n4 <NA>                                     0          0     0     1\n\n\nWir können so erkennen, dass für PayPal-Zahlungen nur sehr selten ein Kreditkartenanbieter hinterlegt ist. Bei den Shopify-Payments hingegen ist das in den meisten Bestellungen der Fall. Dabei liegt Mastercard knapp vor Visa, American Express ist eher die Ausnahme.\n\n\n\n\n\n\nEs wäre doch interessant zu wissen, warum genau eine Bestellung keine Angabe zur Zahlungsart besitzt. Prüft doch mal nach, welche das ist und versucht die Frage zu beantworten."
  },
  {
    "objectID": "explore-new-data-sets.html#datentypen",
    "href": "explore-new-data-sets.html#datentypen",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.3 Datentypen",
    "text": "2.3 Datentypen\nDie schnellste und, wie ich finde, einfachste Möglichkeit, einen Überblick über die Datentypen in einem Tibble zu erhalten, ist die glimpse-Funktion:\n\norders %>% \n  glimpse()\n\nRows: 2,874\nColumns: 68\n$ order_id                              <dbl> 1.130007e+12, 1.130015e+12, 1.13~\n$ name                                  <chr> \"B1014\", \"B1015\", \"B1016\", \"B101~\n$ order_number                          <dbl> 1014, 1015, 1016, 1017, 1018, 10~\n$ app_id                                <dbl> 580111, 580111, 580111, 580111, ~\n$ created_at                            <dttm> 2019-05-24 12:59:16, 2019-05-24~\n$ updated_at                            <dttm> 2019-06-19 13:23:26, 2019-06-21~\n$ test                                  <lgl> FALSE, FALSE, FALSE, FALSE, FALS~\n$ current_subtotal_price                <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ current_total_price                   <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ current_total_discounts               <dbl> 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0,~\n$ current_total_duties_set              <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_discounts                       <dbl> 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0,~\n$ total_line_items_price                <dbl> 96.66, 32.22, 32.22, 32.22, 32.2~\n$ total_outstanding                     <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_price                           <dbl> 94.66, 32.22, 30.22, 32.22, 30.2~\n$ total_tax                             <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ total_tip_received                    <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ taxes_included                        <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TR~\n$ discount_codes                        <chr> \"DCBPXGJB1JGA\", NA, \"KY0D5MNEZBM~\n$ financial_status                      <chr> \"paid\", \"paid\", \"paid\", \"paid\", ~\n$ fulfillment_status                    <chr> \"fulfilled\", \"fulfilled\", \"fulfi~\n$ source_name                           <chr> \"web\", \"web\", \"web\", \"web\", \"web~\n$ landing_site                          <chr> \"/password\", \"/wallets/checkouts~\n$ landing_site_ref                      <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ location_id                           <dbl> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ note                                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ tags                                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ processed_at                          <dttm> 2019-05-24 12:59:15, 2019-05-24~\n$ processing_method                     <chr> \"direct\", \"express\", \"express\", ~\n$ payment_details_gateway               <chr> \"shopify_payments\", \"paypal\", \"p~\n$ payment_details_credit_card_company   <chr> \"Mastercard\", NA, NA, NA, NA, NA~\n$ customer_id                           <dbl> 1.861678e+12, 1.856892e+12, 1.87~\n$ customer_accepts_marketing            <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~\n$ customer_accepts_marketing_updated_at <dttm> 2019-05-21 13:38:54, 2019-05-24~\n$ customer_marketing_opt_in_level       <chr> \"single_opt_in\", \"single_opt_in\"~\n$ customer_sms_marketing_consent        <lgl> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ customer_created_at                   <dttm> 2019-05-13 14:41:16, 2019-05-10~\n$ customer_updated_at                   <dttm> 2022-02-23 13:50:50, 2022-06-21~\n$ customer_gender                       <chr> \"f\", \"m\", \"m\", \"m\", \"f\", \"m\", \"m~\n$ customer_is_hsos                      <dbl> 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0,~\n$ customer_state                        <chr> \"disabled\", \"disabled\", \"enabled~\n$ customer_orders_count                 <dbl> 7, 10, 3, 1, 2, 1, 1, 1, 3, 6, 1~\n$ customer_total_spent                  <dbl> 345.22, 338.40, 95.17, 32.22, 66~\n$ customer_last_order_id                <dbl> 4.640512e+12, 5.053779e+12, 1.95~\n$ customer_note                         <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ customer_verified_email               <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~\n$ customer_tax_exempt                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~\n$ customer_tags                         <chr> \"password page, prospect, umfrag~\n$ customer_last_order_name              <chr> \"41005353622\", \"41005379922\", \"1~\n$ campaign_tag                          <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ shipping_address_city                 <chr> NA, \"Osnabrück\", NA, NA, NA, NA,~\n$ shipping_address_zip                  <dbl> NA, 49088, NA, NA, NA, NA, 49090~\n$ shipping_address_country              <chr> NA, \"Germany\", NA, NA, NA, NA, \"~\n$ shipping_address_latitude             <dbl> NA, 52.29756, NA, NA, NA, NA, 52~\n$ shipping_address_longitude            <dbl> NA, 8.058480, NA, NA, NA, NA, 8.~\n$ billing_address_city                  <chr> \"Quakenbrück\", \"Osnabrück\", \"Osn~\n$ billing_address_zip                   <dbl> 49610, 49088, 49080, 45888, 4935~\n$ billing_address_country               <chr> \"Germany\", \"Germany\", \"Germany\",~\n$ billing_address_company               <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ billing_address_latitude              <dbl> 52.67033, 52.29756, 52.26469, 51~\n$ billing_address_longitude             <dbl> 7.959575, 8.058480, 8.035603, 7.~\n$ client_details_browser_ip             <chr> \"131.173.97.189\", \"131.173.96.36~\n$ client_details_browser_height         <dbl> 665, 1010, 657, 600, 560, 553, 5~\n$ client_details_browser_width          <dbl> 1263, 2048, 1349, 360, 360, 375,~\n$ client_details_user_agent             <chr> \"Mozilla/5.0 (Windows NT 10.0; W~\n$ cancel_reason                         <chr> NA, NA, NA, NA, NA, NA, NA, NA, ~\n$ cancelled_at                          <dttm> NA, NA, NA, NA, NA, NA, NA, NA,~\n$ closed_at                             <dttm> 2019-06-19 13:23:26, 2019-06-21~\n\n\nNeben dem Namen der Spalten erhalten wir den Datentyp sowie eine Vorschau der ersten in jeder Spalte enthaltenen Werte. Auch die Anzahl Zeilen und Spalten nennt uns glimpse.\nEtwas technischer geht es mit der spec-Funktion. Diese liefert statt des Datentyp-Kürzels auch gleich die genaue Spezfikation als R-Funktion zurück:\n\nspec(orders)\n\ncols(\n  order_id = col_double(),\n  name = col_character(),\n  order_number = col_double(),\n  app_id = col_double(),\n  created_at = col_datetime(format = \"\"),\n  updated_at = col_datetime(format = \"\"),\n  test = col_logical(),\n  current_subtotal_price = col_double(),\n  current_total_price = col_double(),\n  current_total_discounts = col_double(),\n  current_total_duties_set = col_double(),\n  total_discounts = col_double(),\n  total_line_items_price = col_double(),\n  total_outstanding = col_double(),\n  total_price = col_double(),\n  total_tax = col_double(),\n  total_tip_received = col_double(),\n  taxes_included = col_logical(),\n  discount_codes = col_character(),\n  financial_status = col_character(),\n  fulfillment_status = col_character(),\n  source_name = col_character(),\n  landing_site = col_character(),\n  landing_site_ref = col_character(),\n  location_id = col_double(),\n  note = col_character(),\n  tags = col_character(),\n  processed_at = col_datetime(format = \"\"),\n  processing_method = col_character(),\n  payment_details_gateway = col_character(),\n  payment_details_credit_card_company = col_character(),\n  customer_id = col_double(),\n  customer_accepts_marketing = col_double(),\n  customer_accepts_marketing_updated_at = col_datetime(format = \"\"),\n  customer_marketing_opt_in_level = col_character(),\n  customer_sms_marketing_consent = col_logical(),\n  customer_created_at = col_datetime(format = \"\"),\n  customer_updated_at = col_datetime(format = \"\"),\n  customer_gender = col_character(),\n  customer_is_hsos = col_double(),\n  customer_state = col_character(),\n  customer_orders_count = col_double(),\n  customer_total_spent = col_double(),\n  customer_last_order_id = col_double(),\n  customer_note = col_character(),\n  customer_verified_email = col_double(),\n  customer_tax_exempt = col_double(),\n  customer_tags = col_character(),\n  customer_last_order_name = col_character(),\n  campaign_tag = col_character(),\n  shipping_address_city = col_character(),\n  shipping_address_zip = col_double(),\n  shipping_address_country = col_character(),\n  shipping_address_latitude = col_double(),\n  shipping_address_longitude = col_double(),\n  billing_address_city = col_character(),\n  billing_address_zip = col_double(),\n  billing_address_country = col_character(),\n  billing_address_company = col_character(),\n  billing_address_latitude = col_double(),\n  billing_address_longitude = col_double(),\n  client_details_browser_ip = col_character(),\n  client_details_browser_height = col_double(),\n  client_details_browser_width = col_double(),\n  client_details_user_agent = col_character(),\n  cancel_reason = col_character(),\n  cancelled_at = col_datetime(format = \"\"),\n  closed_at = col_datetime(format = \"\")\n)\n\n\nFällt uns auf, dass ein Datentyp falsch erkannt wurde, so können wir entweder unseren Ladevorgang anpassen und etwa den Datentyp direkt beim Lesen korrigieren. Alternativ verändern wir die Spalte mit mutate, was wir in Kapitel 4 lernen werden."
  },
  {
    "objectID": "explore-new-data-sets.html#spaltennamen",
    "href": "explore-new-data-sets.html#spaltennamen",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.4 Spaltennamen",
    "text": "2.4 Spaltennamen\nIst man noch nicht lange mit einem Datensatz vertraut, ist eine Funktion für die Auflistung der Spaltennamen hilfreich:\n\norders %>% \n  colnames()\n\n [1] \"order_id\"                             \n [2] \"name\"                                 \n [3] \"order_number\"                         \n [4] \"app_id\"                               \n [5] \"created_at\"                           \n [6] \"updated_at\"                           \n [7] \"test\"                                 \n [8] \"current_subtotal_price\"               \n [9] \"current_total_price\"                  \n[10] \"current_total_discounts\"              \n[11] \"current_total_duties_set\"             \n[12] \"total_discounts\"                      \n[13] \"total_line_items_price\"               \n[14] \"total_outstanding\"                    \n[15] \"total_price\"                          \n[16] \"total_tax\"                            \n[17] \"total_tip_received\"                   \n[18] \"taxes_included\"                       \n[19] \"discount_codes\"                       \n[20] \"financial_status\"                     \n[21] \"fulfillment_status\"                   \n[22] \"source_name\"                          \n[23] \"landing_site\"                         \n[24] \"landing_site_ref\"                     \n[25] \"location_id\"                          \n[26] \"note\"                                 \n[27] \"tags\"                                 \n[28] \"processed_at\"                         \n[29] \"processing_method\"                    \n[30] \"payment_details_gateway\"              \n[31] \"payment_details_credit_card_company\"  \n[32] \"customer_id\"                          \n[33] \"customer_accepts_marketing\"           \n[34] \"customer_accepts_marketing_updated_at\"\n[35] \"customer_marketing_opt_in_level\"      \n[36] \"customer_sms_marketing_consent\"       \n[37] \"customer_created_at\"                  \n[38] \"customer_updated_at\"                  \n[39] \"customer_gender\"                      \n[40] \"customer_is_hsos\"                     \n[41] \"customer_state\"                       \n[42] \"customer_orders_count\"                \n[43] \"customer_total_spent\"                 \n[44] \"customer_last_order_id\"               \n[45] \"customer_note\"                        \n[46] \"customer_verified_email\"              \n[47] \"customer_tax_exempt\"                  \n[48] \"customer_tags\"                        \n[49] \"customer_last_order_name\"             \n[50] \"campaign_tag\"                         \n[51] \"shipping_address_city\"                \n[52] \"shipping_address_zip\"                 \n[53] \"shipping_address_country\"             \n[54] \"shipping_address_latitude\"            \n[55] \"shipping_address_longitude\"           \n[56] \"billing_address_city\"                 \n[57] \"billing_address_zip\"                  \n[58] \"billing_address_country\"              \n[59] \"billing_address_company\"              \n[60] \"billing_address_latitude\"             \n[61] \"billing_address_longitude\"            \n[62] \"client_details_browser_ip\"            \n[63] \"client_details_browser_height\"        \n[64] \"client_details_browser_width\"         \n[65] \"client_details_user_agent\"            \n[66] \"cancel_reason\"                        \n[67] \"cancelled_at\"                         \n[68] \"closed_at\"                            \n\n\nDiese Information liefert einem auch glimpse, wie oben gezeigt. Mit colnames bekommen wir die Spaltennamen als Vektor, was nützlich sein kann, um damit weiter arbeiten zu können."
  },
  {
    "objectID": "explore-new-data-sets.html#stichproben-betrachten",
    "href": "explore-new-data-sets.html#stichproben-betrachten",
    "title": "\n2  Datensätze erkunden\n",
    "section": "\n2.5 Stichproben betrachten",
    "text": "2.5 Stichproben betrachten\nFür einen ersten Eindruck der Daten reicht es oft schon, sich ein paar Zeilen anzeigen zu lassen. Das geht mit unterschiedlichen Funktionen:\n\n# Zeigt standardmäßig die ersten 6 Zeilen anan\norders %>% \n  head()\n\n# Zeigt die ersten 20 Zeilen an\norders %>% \n  head(20)\n\n# Wenn man mehr anzeigen möchte, kann print verwendet werdenn\norders %>% \n  print(n = 100)\n\n# Das Ganze geht auch von unten\norders %>% \n  tail()\n\nMöchte man nicht die oberen oder unteren Zeilen anzeigen, sondern eine zufällige Auswahl, so hilft sample_n:\n\norders %>% \n  sample_n(size = 5)\n\n# A tibble: 5 x 68\n     order_id name  order~1 app_id created_at          updated_at          test \n        <dbl> <chr>   <dbl>  <dbl> <dttm>              <dttm>              <lgl>\n1     4.20e12 4100~    2829 580111 2021-10-13 07:53:57 2021-10-14 11:00:49 FALSE\n2     4.22e12 4100~    2927 580111 2021-10-21 10:52:04 2021-11-09 12:47:08 FALSE\n3     2.32e12 4100~    1750 580111 2020-05-28 12:59:21 2020-05-31 10:26:59 FALSE\n4     3.70e12 4100~    2528 580111 2021-03-25 11:12:05 2021-03-25 11:36:23 FALSE\n5     1.88e12 1681~    1226 580111 2019-11-15 05:37:46 2019-12-13 15:19:30 FALSE\n# ... with 61 more variables: current_subtotal_price <dbl>,\n#   current_total_price <dbl>, current_total_discounts <dbl>,\n#   current_total_duties_set <dbl>, total_discounts <dbl>,\n#   total_line_items_price <dbl>, total_outstanding <dbl>, total_price <dbl>,\n#   total_tax <dbl>, total_tip_received <dbl>, taxes_included <lgl>,\n#   discount_codes <chr>, financial_status <chr>, fulfillment_status <chr>,\n#   source_name <chr>, landing_site <chr>, landing_site_ref <chr>, ...\n\n\nUm ein bestimmten prozentualen Anteil an den gesamten Zeilen zufällig zu ermitteln, gibt es sample_frac:\n\n# Gibt zufällig gewählte Zeilen zurück, die 1% entsprechenhen\norders %>% \n  sample_frac(size = 0.01)\n\n# A tibble: 29 x 68\n     order_id name  order~1 app_id created_at          updated_at          test \n        <dbl> <chr>   <dbl>  <dbl> <dttm>              <dttm>              <lgl>\n 1    4.12e12 4100~    2662 5.80e5 2021-09-09 17:50:33 2021-09-14 11:40:16 FALSE\n 2    4.26e12 4100~    3125 5.80e5 2021-11-12 15:51:12 2021-11-15 11:01:23 FALSE\n 3    4.61e12 4100~    3410 5.80e5 2021-12-14 18:48:38 2021-12-20 13:52:28 FALSE\n 4    4.24e12 4100~    3056 5.80e5 2021-11-02 14:47:10 2021-11-09 12:46:36 FALSE\n 5    1.88e12 1681~    1217 5.80e5 2019-11-14 21:45:03 2019-12-13 17:14:25 FALSE\n 6    4.19e12 4100~    2806 5.80e5 2021-10-07 06:31:08 2021-10-12 08:09:16 FALSE\n 7    1.88e12 1681~    1197 5.80e5 2019-11-14 15:23:14 2019-12-13 15:27:00 FALSE\n 8    4.22e12 4100~    2930 5.80e5 2021-10-21 12:07:32 2021-11-09 12:47:08 FALSE\n 9    3.18e12 4100~    2425 5.80e5 2021-01-08 15:24:07 2021-01-14 15:26:31 FALSE\n10    4.22e12 4100~    2952 1.35e6 2021-10-22 16:30:18 2021-11-09 09:06:02 FALSE\n# ... with 19 more rows, 61 more variables: current_subtotal_price <dbl>,\n#   current_total_price <dbl>, current_total_discounts <dbl>,\n#   current_total_duties_set <dbl>, total_discounts <dbl>,\n#   total_line_items_price <dbl>, total_outstanding <dbl>, total_price <dbl>,\n#   total_tax <dbl>, total_tip_received <dbl>, taxes_included <lgl>,\n#   discount_codes <chr>, financial_status <chr>, fulfillment_status <chr>,\n#   source_name <chr>, landing_site <chr>, landing_site_ref <chr>, ..."
  }
]