[
  {
    "objectID": "case-covid.html",
    "href": "case-covid.html",
    "title": "Fall: Covid",
    "section": "",
    "text": "Wie verdeutlichen wir Trends und Entwicklungen über die Zeit?"
  },
  {
    "objectID": "case-covid.html#datensatz",
    "href": "case-covid.html#datensatz",
    "title": "Fall: Covid",
    "section": "Datensatz",
    "text": "Datensatz"
  },
  {
    "objectID": "tidyverse.html#tibbles",
    "href": "tidyverse.html#tibbles",
    "title": "\n1  Das Tidyverse\n",
    "section": "\n1.2 Tibbles",
    "text": "1.2 Tibbles\nIn Kapitel X haben wir den Dataframe als Datenstruktur in R kennengelernt. Mit einem Dataframe können wir tabellarische Daten, wie wir sie aus Spreadsheet-Programmen wie Microsoft Excel oder Google Sheets kennen, in R abbilden. Das Tidyverse bringt eine verbesserte Version des klassischen Dataframes mit, das Tibble.\nDer Name Tibble leitet sich vermutlich aus dem Begriff Tidy Table ab. Ein Tibble bringt die folgenden Verbesserungen im Vergleich zu einem klassischen Dataframe mit sich:\n\nKürzere und prägnantere Ausgabe auf der Konsole.\nKeine Veränderung von Spaltennamen im Vergleich zur Quelle.\nKeine Umwandlung von Zeichenketten in Faktoren als Standard.\nEin Tibble erzeugt keine Namen für Zeilen (rownames)\n\nAusgabe auf der Konsole\nEine nützliche Verbesserung ist die sinnvollere Ausgabe eines Tibbles auf der Konsole. Das Beispiel unten gibt das Tibble tweets, das wir im nächsten Kapitel laden werden, auf der Konsole aus:\n\ntweets\n\n# A tibble: 46,787 x 22\n   id             screen_name text  retweet_count favorite_count is_quote_status\n   <chr>          <chr>       <chr>         <dbl>          <dbl> <lgl>          \n 1 1518891431288~ MarcoBusch~ \"beg~             3             12 FALSE          \n 2 1518891429820~ MarcoBusch~ \"Die~             3             15 FALSE          \n 3 1518907549420~ starkwatzi~ \"@Ko~             1             10 FALSE          \n 4 1518907549420~ starkwatzi~ \"@Ko~             1             10 FALSE          \n 5 1518916990915~ NancyFaeser \"Uns~            53            490 FALSE          \n 6 1518916990915~ NancyFaeser \"Uns~            53            490 FALSE          \n 7 1518947908980~ c_lindner   \"So ~             6             53 FALSE          \n 8 1518960421214~ MarcoBusch~ \"@ar~             1              4 FALSE          \n 9 1518957407845~ MarcoBusch~ \"Bei~            20             99 FALSE          \n10 1518922009157~ MarcoBusch~ \"@sc~             1              0 FALSE          \n# ... with 46,777 more rows, and 16 more variables: is_retweet <lgl>,\n#   lang <chr>, in_reply_to_screen_name <chr>, in_reply_to_status_id <chr>,\n#   hashtags <list>, urls <list>, user_mentions <list>, photos <list>,\n#   source <chr>, insert_timestamp <chr>, created_at <dttm>, quote_count <dbl>,\n#   reply_count <dbl>, retweeted_status_id <chr>, retweeted_user <chr>,\n#   quoted_status_id <chr>\n\n\nWäre tweets ein normaler Dateframe bekämen wir eine sehr lange Ausgabe aller 46787 Zeilen und 22 Spalten. Ein Tibble zeigt uns nur die ersten 10 Zeilen als Beispiele, mit jeweils so vielen Spalten wie sinnvoll in die Ausgabe passen. Die Information, dass es noch weitere Zeilen und Spalten gibt (und wieviele), folgt darunter.\nTibbles sind auch Dataframes\nJedes Tibble ist gleichzeitig ein klassischer Dataframe. Es besitzt aber zusätzlich die Klassen tbl und tbl_df, die für die zusätzlichen Funktionen und das veränderte Verhalten sorgen.\nZur Illustration erstellen wir manuell einen Dataframe und einen Tibble und lassen uns danach mit class die R-Klassen ausgeben, die beide Objekte besitzen:\n\ndf <- data.frame(id = c(1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nclass(df)\n\n[1] \"data.frame\"\n\n\nUnd nun das Tibble:\n\ntbl <- tibble(id = c (1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nclass(tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nDadurch, dass ein Tibble auch gleichzeitig ein klassischer Dataframe ist, können wir alle Funktionen darauf anwenden, die auch mit Dataframes funktionieren. Schließlich ist ein Tibble ja ein Dataframe.\n\ncolnames(tbl)\n\n[1] \"id\"   \"name\"\n\n\nWir können jederzeit aus einem Dataframe ein Tibble erzeugen:\n\ndf <- as_tibble(df)\n\ndf\n\n# A tibble: 3 x 2\n     id name \n  <dbl> <chr>\n1     1 Mark \n2     2 John \n3     3 Eve  \n\n\nDas manuelle Erzeugen eine Tibble geht auf 2 unterschiedliche Wege. Zum einen mit der tibble Funktion, die Paare aus Spaltenname und zugehörige Werte als Vektor erwartet (s. oben):\n\ntbl <- tibble(id = c (1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nEine andere Möglichkeite ist die zeilenweise Erstellung mit tribble:\n\ntbl <- tribble(\n  ~id, ~name,\n    1, \"Mark\",\n    2, \"John\",\n    3, \"Eve\"\n)"
  },
  {
    "objectID": "tidyverse.html#mehr-lesen",
    "href": "tidyverse.html#mehr-lesen",
    "title": "\n1  Das Tidyverse\n",
    "section": "Mehr lesen",
    "text": "Mehr lesen\n\nLink zur offziellen Webseite des Tidyverse\nLink zur Dokumentation des Tibble-Pakets"
  },
  {
    "objectID": "r-load-csv-data.html",
    "href": "r-load-csv-data.html",
    "title": "\n2  CSV-Daten laden mit R\n",
    "section": "",
    "text": "Im ersten Schritt jeder Datenanalyse müssen wir unserem Computer den Datensatz zur Verfügung stellen. Wir sprechen dabei auch vom Laden des Datesatzes. Dabei sagen wir dem Computer, wo die Daten zu finden sind und dass er sie für den schnelleren Zugriff in seinen Arbeitsspeicher holen soll.\nDaten liegen in den meisten Fällen in Form von Dateien vor. In manchen Fällen sind sie auch in einer Datenbank gespeichert. Im Fall einer Datei kann ein Datensatz in unterschiedlichen Formaten darin gespeichert werden. Ein gängiges Format ist das CSV-Format."
  },
  {
    "objectID": "r-load-csv-data.html#das-paket-readr",
    "href": "r-load-csv-data.html#das-paket-readr",
    "title": "2  CSV-Daten laden mit R",
    "section": "2.1 Das Paket readr",
    "text": "2.1 Das Paket readr"
  },
  {
    "objectID": "case-twitter-a.html",
    "href": "case-twitter-a.html",
    "title": "Fall: Tweets",
    "section": "",
    "text": "Was ist SQL und wofür können wir es verwenden?\nWie können wir mit SQL Daten abfragen?"
  },
  {
    "objectID": "case-twitter-a.html#datensatz",
    "href": "case-twitter-a.html#datensatz",
    "title": "Fall: Tweets",
    "section": "Datensatz",
    "text": "Datensatz"
  },
  {
    "objectID": "sql-intro.html",
    "href": "sql-intro.html",
    "title": "4  Was ist SQL?",
    "section": "",
    "text": "Die Abkürzung SQL steht für Structured Query Language und hat seine Wurzeln bei den relationalen Datenbanken. Relationale Datenbanken wurden in den 1970er-Jahren entwickelt und als kommerzielle Produkte eingeführt. Sie werden vorrangig für die Verwaltung von strukturierten, operativen Geschäftsdaten verwendet. Bis heute sind relationale Datenbanken weitverbreitet, wir finden sie zum Beispiel in großen Informationssystemen wie dem ERP-System der Firma SAP.\nDie Abfragesprache SQL wurde entwickelt, um möglichst einfach Informationen aus relationalen Datenbanken extrahieren zu können. Mit SQL lassen sich Daten aber nicht nur extrahieren, sondern auch erzeugen, verändern oder löschen. In unserem Kontext geht es um die Analysex von Daten und wir betrachten deshalb nur die Möglichkeiten zur Abfrage von Daten. Der SQL-Befehl select mit seinen Facetten steht dabei im Mittelpunkt"
  },
  {
    "objectID": "sql-intro.html#standardisierung-und-dialekte",
    "href": "sql-intro.html#standardisierung-und-dialekte",
    "title": "4  Was ist SQL?",
    "section": "4.2 Standardisierung und Dialekte",
    "text": "4.2 Standardisierung und Dialekte\nWeil es viele unterschiedliche kommerzielle Hersteller relationaler Datenbanken gibt (z. B. Oracle, SAP, Microsoft, Teradata) und daneben viele Open Source Produkte (z. B. MySQL, PostgreSQL) wurde SQL 1986 standardisiert (s. ANSI X3.135 und ISO 9075-1987). Trotz der Standardisierung, in der die grundlegende Syntax und der Funktionsumfang festgelegt wurden, gibt es heute unterschiedliche Dialekte von SQL. Diese unterscheiden sich in Details wie ob eine spezifische erweiterte Funktion existiert oder nicht. Durch die Standardisierung gilt aber: Wenn man SQL in einem Dialekt beherrscht, dann ist es ohne Probleme möglich auch andere Dialekte zu verwenden.\nSQL ist somit unverzichtbar, wenn wir Daten aus relationalen Datenbanken abfragen oder exportieren wollen. Da viele Informationssysteme in Unternehmen auf relationalen Datenbanken basieren, spielt SQL gerade im betriebswirtschaftlichen Kontext eine große Rolle.\nWegen der weiten Verbreitung von SQL ermöglichen auch andere Werkzeuge, Daten mit dieser Sprache zu analysieren. Ein Beispiel ist Apache Spark, ein Open-Source Werkzeug für die Verarbeitung und Analyse großer Datenmengen (Big Data). Hier gibt es eine eigene Schnittstelle (API) für SQL, die den Namen Spark SQL trägt. Wir verwenden Spark SQL in meinen Kursen in der Databricks Cloud-Umgebung. Klickt auf den Link unten, um direkt mit SQL zu beginnen."
  },
  {
    "objectID": "sql-intro.html#weiterlesen",
    "href": "sql-intro.html#weiterlesen",
    "title": "4  Was ist SQL?",
    "section": "Weiterlesen",
    "text": "Weiterlesen\n\nMein Blogbeitrag What is SQL - and what can we do with it? auf Medium"
  },
  {
    "objectID": "case-rewe.html",
    "href": "case-rewe.html",
    "title": "Fall 2 : REWE",
    "section": "",
    "text": "Wie stellen wir Größenverhältnisse (Proportionen) effektiv dar?"
  },
  {
    "objectID": "case-rewe.html#daten",
    "href": "case-rewe.html#daten",
    "title": "Fall 2 : REWE",
    "section": "Daten",
    "text": "Daten"
  },
  {
    "objectID": "case-rewe.html#datensatz",
    "href": "case-rewe.html#datensatz",
    "title": "Fall 2 : REWE",
    "section": "Datensatz",
    "text": "Datensatz\nDer Datensatz besteht aus einem Snapshot aus dem März 2018 aller im REWE Online-Shop angebotenen Produkte.\n\n\n\n\n\n\nWas ist ein Snapshot?\n\n\n\nEin Snapshot ist der Stand eines Datensatzes zu einem bestimmten Zeitpunkt in der Vergangenheit. In diesem Fall wurden die Daten an einem besitmmten Tag aus dem REWE Online-Shop abgegriffen und gespeichert. Die Daten auf der Webseite können sich seitdem verändert haben. Der Datensatz reflektiert diese Änderungen nicht, er bleibt auf dem Stand der Erstellung."
  },
  {
    "objectID": "long-wide-data.html",
    "href": "long-wide-data.html",
    "title": "6  Lange und breite Daten",
    "section": "",
    "text": "Wie bereits in Abschnitt Fall 2: Covid gesehen, können Daten in unterschiedlicher Form vorliegen."
  },
  {
    "objectID": "r-load-csv-data.html#das-csv-format",
    "href": "r-load-csv-data.html#das-csv-format",
    "title": "\n2  CSV-Daten laden mit R\n",
    "section": "\n2.1 Das CSV-Format",
    "text": "2.1 Das CSV-Format\nStrukturierte Daten\nCSV steht für Comma Separated Values und beschreibt ein Format, um strukturierte Daten in einer Textdatei abzuspeichern. Ihr erkennt eine Textdatei im CSV-Format an der Endung .csv.\nDas CSV-Format ist das wohl verbreitetste Format für die Speicherung und den Austausch von strukturierten Daten. Fast jede Software, die Daten verwaltet oder analysiert, bietet Schnittstellen für CSV-Dateien an. Dafür gibt es gute Gründe:\n\nDie Verwendung von einfachen Textdateien erlaubt die Speicherung und Verarbeitung auf unterschiedlichen Umgebungen wie Windows, macOS oder Linux.\nDas Format ist einfach zu verstehen und auch für Menschen lesbar.\nCSV ist ein offenes Format, d. h. es gibt keine Organisation, die daran die Rechte besitzt und es kann daher von jeder Software verwendet werden. Es gab lange nicht einmal eine offizielle Spezifikation des Formats. Mittlerweile gibt es eine Spezifikation als offizieller MIME Type.\nKopfzeile und Trennzeichen\nDas CSV-Format speichert strukturierte Daten in einer tabellarischen Form, ähnlich wie in Spreadsheets. Jede Zeile stellt eine Beobachtung (Englisch: observation oder case) oder Datensatz (Englisch: record) dar, und jeder Datensatz hat verschiedene Attribute (oder Spalten), deren Werte durch ein Komma voneinander getrennt sind. Das Komma als Trennzeichen ist keineswegs verbindlich. Generell kann jedes Symbol verwendet werden. Häufige Alternativen sind das Semikolon, Leerzeichen oder ein Tabstop. Letzteres wird oft mit der eigenen Endung .tsv für Tab Separated Values gespeichert.\nUnten ihr einen Ausschnitt aus dem Covid19-Datensatz von Our World in Data, wie man ihn in einem einfachen Texteditor wie Notepad++ anzeigen lassen kann. Man erkennt schnell, dass sich die erste Zeile von den anderen unterscheidet: Sie beinhaltet die Spaltennamen, die hintereinander durch das Trennzeichen (hier: Komma) getrennt aufgelistet werden. Man nennt die erste Zeile auch Kopfzeile (Englisch: Header). Die Kopfzeile ist nicht verpflichtend. Es gibt auch CSV-Dateien ohne Kopfzeile. In diesem Fall muss die Benennung der Spalten später manuell erfolgen.\nNach der Kopfzeile stellt jede weitere Zeile die Spaltenwerte eines Datensatzes (oder Beobachtung) dar. Diese werden stets in der gleichen Reihenfolge wie in der Kopfzeile durch das Trennzeichen (hier: Komma) voneinander getrennt aufgelistet. Diese Regel ist wichtig, da sonst die Zuordnung von Werten zu Spaltennamen unmöglich wäre.\nEs muss nicht jeder Spaltenwert existieren. Sollte ein Wert für eine Beobachtung nicht vorhanden sein, so wird einfach nach dem Komma nichts eingetragen und es folgen zwei Kommata nacheinander.\niso_code,continent,location,date,total_cases,new_cases, ...\nDEU,Europe,Germany,2020-01-27,1.0,1.0, ...\nDEU,Europe,Germany,2020-01-28,4.0,3.0, ...\nDEU,Europe,Germany,2020-01-29,4.0,0.0, ...\nDEU,Europe,Germany,2020-01-30,4.0,0.0, ...\n..."
  },
  {
    "objectID": "r-load-csv-data.html#die-funktion-read_csv",
    "href": "r-load-csv-data.html#die-funktion-read_csv",
    "title": "\n2  CSV-Daten laden mit R\n",
    "section": "\n2.2 Die Funktion read_csv\n",
    "text": "2.2 Die Funktion read_csv\n\nDie Funktion read_csv aus dem readr Paket erlaubt und das effiziente Laden von Daten aus CSV-Dateien. Der Code unten lädt die tagesaktuelle Version des Covid-19 Datensatzes von Our World in Data:\n\ncovid <- read_csv(\"https://covid.ourworldindata.org/data/owid-covid-data.csv\")\n\nRows: 193573 Columns: 67\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr   (4): iso_code, continent, location, tests_units\ndbl  (62): total_cases, new_cases, new_cases_smoothed, total_deaths, new_dea...\ndate  (1): date\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message."
  }
]