[
  {
    "objectID": "case-climate-data.html",
    "href": "case-climate-data.html",
    "title": "Fall: Klima",
    "section": "",
    "text": "Der Datensatz stammt von der offiziellen Seite des Deutschen Wetterdienstes, der dort Klimadaten zum direkten Download bereitstellt. Die Daten werden als Textdateien bereitgestellt, die wir im Kapitel “Textdateien einlesen” genauer betrachten.\nDaten"
  },
  {
    "objectID": "read-txt-files.html",
    "href": "read-txt-files.html",
    "title": "\n3  Textdateien einlesen\n",
    "section": "",
    "text": "library(dplyr)\nlibrary(readr)\nlibrary(janitor)\n\nstations <- read_csv2(\"./data/stations_list_CLIMAT_data.txt\")\n\n# Rows: 4510 Columns: 6\n# -- Column specification -------------------------------------------------\n# Delimiter: \";\"\n# chr (6): WMO-Station ID, StationName, Latitude, Longitude, Height, Co...\n\n\nOben haben wir mit janitor ein nützliches Paket eingeführt. Wir verwenden daraus die Funktion clean_names, die wir unmittelbar an das Laden der Daten mit read_delim aufrufen. Was macht diese Funktion?\nUm den Effekt der clean_names Funktion zu beleuchten, schauen wir uns das Ergebnis einmal mit und ohne diese Funktion an:\n\nstations %>%  \n  colnames()\n\n# [1] \"WMO-Station ID\" \"StationName\"    \"Latitude\"       \"Longitude\"     \n# [5] \"Height\"         \"Country\"  \n\nstations %>% \n  clean_names() %>% \n  colnames()\n\n# [1] \"wmo_station_id\" \"station_name\"   \"latitude\"       \"longitude\"     \n# [5] \"height\"         \"country\""
  },
  {
    "objectID": "read-txt-files.html#spalten-konvertieren",
    "href": "read-txt-files.html#spalten-konvertieren",
    "title": "\n3  Textdateien einlesen\n",
    "section": "\n3.2 Spalten konvertieren",
    "text": "3.2 Spalten konvertieren\nDie Datentypen der Spalten wurden offensichtlich nicht richtig erkannt."
  },
  {
    "objectID": "tidyverse.html#tibbles",
    "href": "tidyverse.html#tibbles",
    "title": "2  Das Tidyverse",
    "section": "2.2 Tibbles",
    "text": "2.2 Tibbles\nIn Kapitel X haben wir den Dataframe als Datenstruktur in R kennengelernt. Mit einem Dataframe können wir tabellarische Daten, wie wir sie aus Spreadsheet-Programmen wie Microsoft Excel oder Google Sheets kennen, in R abbilden. Das Tidyverse bringt eine verbesserte Version des klassischen Dataframes mit, das Tibble.\nDer Name Tibble leitet sich vermutlich aus dem Begriff Tidy Table ab. Ein Tibble bringt die folgenden Verbesserungen im Vergleich zu einem klassischen Dataframe mit sich:\n\nKürzere und prägnantere Ausgabe auf der Konsole.\nKeine Veränderung von Spaltennamen im Vergleich zur Quelle.\nKeine Umwandlung von Zeichenketten in Faktoren als Standard.\nEin Tibble erzeugt keine Namen für Zeilen (rownames)\n\n\nAusgabe auf der Konsole\nEine nützliche Verbesserung ist die sinnvollere Ausgabe eines Tibbles auf der Konsole. Das Beispiel unten gibt das Tibble tweets, das wir im nächsten Kapitel laden werden, auf der Konsole aus:\n\ntweets\n\n\n\n  \n\n\n\nWäre tweets ein normaler Dateframe bekämen wir eine sehr lange Ausgabe aller\n\n\n\n\nZeilen und 22 Spalten. Ein Tibble zeigt uns nur die ersten 10 Zeilen als Beispiele, mit jeweils so vielen Spalten wie sinnvoll in die Ausgabe passen. Die Information, dass es noch weitere Zeilen und Spalten gibt (und wieviele), folgt darunter.\n\n\nTibbles sind auch Dataframes\nJedes Tibble ist gleichzeitig ein klassischer Dataframe. Es besitzt aber zusätzlich die Klassen tbl und tbl_df, die für die zusätzlichen Funktionen und das veränderte Verhalten sorgen.\nZur Illustration erstellen wir manuell einen Dataframe und einen Tibble und lassen uns danach mit class die R-Klassen ausgeben, die beide Objekte besitzen:\n\ndf <- data.frame(id = c(1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nclass(df)\n\n[1] \"data.frame\"\n\n\nUnd nun das Tibble:\n\ntbl <- tibble(id = c (1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nclass(tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nDadurch, dass ein Tibble auch gleichzeitig ein klassischer Dataframe ist, können wir alle Funktionen darauf anwenden, die auch mit Dataframes funktionieren. Schließlich ist ein Tibble ja ein Dataframe.\n\ncolnames(tbl)\n\n[1] \"id\"   \"name\"\n\n\nWir können jederzeit aus einem Dataframe ein Tibble erzeugen:\n\ndf <- as_tibble(df)\n\ndf\n\n\n\n  \n\n\n\nDas manuelle Erzeugen eines Tibble geht auf zwei unterschiedliche Wege. Zum einen mit der tibble Funktion, die Paare aus Spaltenname und zugehörigen Werten als Vektor erwartet (s. oben):\n\ntbl <- tibble(id = c (1, 2, 3), name = c(\"Mark\", \"John\", \"Eve\"))\n\nEine andere Möglichkeit ist die zeilenweise Erstellung mit tribble:\n\ntbl <- tribble(\n  ~id, ~name,\n    1, \"Mark\",\n    2, \"John\",\n    3, \"Eve\"\n)"
  },
  {
    "objectID": "tidyverse.html#mehr-lesen",
    "href": "tidyverse.html#mehr-lesen",
    "title": "2  Das Tidyverse",
    "section": "Mehr lesen",
    "text": "Mehr lesen\n\nLink zur offziellen Webseite des Tidyverse\nLink zur Dokumentation des Tibble-Pakets"
  },
  {
    "objectID": "case-covid.html",
    "href": "case-covid.html",
    "title": "Fall: Covid",
    "section": "",
    "text": "Wie verdeutlichen wir Trends und Entwicklungen über die Zeit?\nSind Daten vertrauenswürdig? Was sind Indizien für oder dagegen?"
  },
  {
    "objectID": "case-covid.html#datensatz",
    "href": "case-covid.html#datensatz",
    "title": "Fall: Covid",
    "section": "Datensatz",
    "text": "Datensatz"
  },
  {
    "objectID": "csv-format.html",
    "href": "csv-format.html",
    "title": "4  Das CSV-Format",
    "section": "",
    "text": "Im ersten Schritt jeder Datenanalyse müssen wir unserem Computer den Datensatz zur Verfügung stellen. Wir sprechen dabei auch vom Laden des Datesatzes. Dabei sagen wir dem Computer, wo die Daten zu finden sind und dass er sie für den schnelleren Zugriff in seinen Arbeitsspeicher holen soll.\nDaten liegen in den meisten Fällen in Form von Dateien vor. In manchen Fällen sind sie auch in einer Datenbank gespeichert. Im Fall einer Datei kann ein Datensatz in unterschiedlichen Formaten darin gespeichert werden. Ein gängiges Format ist das CSV-Format."
  },
  {
    "objectID": "csv-format.html#das-csv-format",
    "href": "csv-format.html#das-csv-format",
    "title": "4  Das CSV-Format",
    "section": "4.1 Das CSV-Format",
    "text": "4.1 Das CSV-Format\n\nStrukturierte Daten\nCSV steht für Comma Separated Values und beschreibt ein Format, um strukturierte Daten in einer Textdatei abzuspeichern. Ihr erkennt eine Textdatei im CSV-Format an der Endung .csv.\nDas CSV-Format ist das wohl verbreitetste Format für die Speicherung und den Austausch von strukturierten Daten. Fast jede Software, die Daten verwaltet oder analysiert, bietet Schnittstellen für CSV-Dateien an. Dafür gibt es gute Gründe:\n\nDie Verwendung von einfachen Textdateien erlaubt die Speicherung und Verarbeitung auf unterschiedlichen Umgebungen wie Windows, macOS oder Linux.\nDas Format ist einfach zu verstehen und auch für Menschen lesbar.\nCSV ist ein offenes Format, d. h. es gibt keine Organisation, die daran die Rechte besitzt und es kann daher von jeder Software verwendet werden. Es gab lange nicht einmal eine offizielle Spezifikation des Formats. Mittlerweile gibt es eine Spezifikation als offizieller MIME Type.\n\n\n\nKopfzeile und Trennzeichen\nDas CSV-Format speichert strukturierte Daten in einer tabellarischen Form, ähnlich wie in Spreadsheets. Jede Zeile stellt eine Beobachtung (Englisch: observation oder case) oder Datensatz (Englisch: record) dar, und jeder Datensatz hat verschiedene Attribute (oder Spalten), deren Werte durch ein Komma voneinander getrennt sind. Das Komma als Trennzeichen ist keineswegs verbindlich. Generell kann jedes Symbol verwendet werden. Häufige Alternativen sind das Semikolon, Leerzeichen oder ein Tabstop. Letzteres wird oft mit der eigenen Endung .tsv für Tab Separated Values gespeichert.\nUnten ihr einen Ausschnitt aus dem Covid19-Datensatz von Our World in Data, wie man ihn in einem einfachen Texteditor wie Notepad++ anzeigen lassen kann. Man erkennt schnell, dass sich die erste Zeile von den anderen unterscheidet: Sie beinhaltet die Spaltennamen, die hintereinander durch das Trennzeichen (hier: Komma) getrennt aufgelistet werden. Man nennt die erste Zeile auch Kopfzeile (Englisch: Header). Die Kopfzeile ist nicht verpflichtend. Es gibt auch CSV-Dateien ohne Kopfzeile. In diesem Fall muss die Benennung der Spalten später manuell erfolgen.\nNach der Kopfzeile stellt jede weitere Zeile die Spaltenwerte eines Datensatzes (oder Beobachtung) dar. Diese werden stets in der gleichen Reihenfolge wie in der Kopfzeile durch das Trennzeichen (hier: Komma) voneinander getrennt aufgelistet. Diese Regel ist wichtig, da sonst die Zuordnung von Werten zu Spaltennamen unmöglich wäre.\nEs muss nicht jeder Spaltenwert existieren. Sollte ein Wert für eine Beobachtung nicht vorhanden sein, so wird einfach nach dem Komma nichts eingetragen und es folgen zwei Kommata nacheinander.\niso_code,continent,location,date,total_cases,new_cases, ...\nDEU,Europe,Germany,2020-01-27,1.0,1.0, ...\nDEU,Europe,Germany,2020-01-28,4.0,3.0, ...\nDEU,Europe,Germany,2020-01-29,4.0,0.0, ...\nDEU,Europe,Germany,2020-01-30,4.0,0.0, ...\n..."
  },
  {
    "objectID": "csv-format.html#die-funktion-read_csv",
    "href": "csv-format.html#die-funktion-read_csv",
    "title": "4  Das CSV-Format",
    "section": "4.2 Die Funktion read_csv",
    "text": "4.2 Die Funktion read_csv\nDie Funktion read_csv aus dem readr Paket erlaubt und das effiziente Laden von Daten aus CSV-Dateien. Der Code unten lädt die tagesaktuelle Version des Covid-19 Datensatzes von Our World in Data:\n\ncovid <- read_csv(\"https://covid.ourworldindata.org/data/owid-covid-data.csv\")\n\nRows: 219868 Columns: 67\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr   (4): iso_code, continent, location, tests_units\ndbl  (62): total_cases, new_cases, new_cases_smoothed, total_deaths, new_dea...\ndate  (1): date\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "trends.html",
    "href": "trends.html",
    "title": "\n5  Trends\n",
    "section": "",
    "text": "Kennzahlen einer globalen Pandemie, wie die täglichen Neuinfektionen, eignen sich gut für die Einführung von Visualisierungsformen für Trends und Entwicklungen. Spätestens sein den Jahren der Pandemie, beginnend im Frühjahr 2020, kennt jeder entsprechende Diagramme aus den Nachrichten. In diesem Kapitel lernen wir, diese und andere Diagramme mit ggplot2 selbst zu erstellen."
  },
  {
    "objectID": "trends.html#liniendiagramme",
    "href": "trends.html#liniendiagramme",
    "title": "\n5  Trends\n",
    "section": "\n5.1 Liniendiagramme",
    "text": "5.1 Liniendiagramme\nEine Serie\nLiniendiagramme verwenden Verbindungen zwischen benachbarten Punkten, um über die Steigung der Linien Entwicklungen sichtbar werden zu lassen. Für die Umsetzung dieser Linien in ggplot2 verwenden wir die Funktion geom_line. Die Punkte selbst werden über die x- und y-Achsen bestimmt. Typischerweise tragen wir auf der x-Achse eine zeitliche Dimension ab, während wir die y-Achse für die betrachtete Größe verwenden.\nFür die folgenden Visualisierungen filtern wir die Daten auf Frankreich und den Januar 2022:\n\ncov_france <- \n  covid %>% \n  filter(location == \"France\", date >= \"2022-01-01\", date <= \"2022-01-31\") %>%\n  select(date, new_cases_smoothed_per_million)\n\nAuf der Grundlage erstellen wir ein Liniendiagramm:\n\ncov_france %>% \n  ggplot() +\n  aes(x = date, y = new_cases_smoothed_per_million) +\n  geom_line()\n\n\n\n\nLinien und Punkte zusammen\nUm die Verbindungen zwischen zwei Punkten deutlicher sichtbar werden zu lassen, können wir zusätzlich zu den Linien auch die Punkte in das Diagramm einzeichnen:\n\ncov_france %>% \n  ggplot() +\n  aes(x = date, y = new_cases_smoothed_per_million) +\n  geom_line() +\n  geom_point()\n\n\n\n\nMehrere Serien\n\ncovid %>% \n  filter(location %in% c(\"France\", \"Spain\"), date >= \"2022-01-01\") %>% \n  select(date, new_cases_smoothed_per_million, location) %>% \n  ggplot() +\n  aes(x = date, y = new_cases_smoothed_per_million, color = location) +\n  geom_line()"
  },
  {
    "objectID": "case-twitter-a.html",
    "href": "case-twitter-a.html",
    "title": "Fall: Tweets",
    "section": "",
    "text": "Was ist SQL und wofür können wir es verwenden?\nWie können wir mit SQL Daten abfragen?"
  },
  {
    "objectID": "case-twitter-a.html#datensatz",
    "href": "case-twitter-a.html#datensatz",
    "title": "Fall: Tweets",
    "section": "Datensatz",
    "text": "Datensatz"
  },
  {
    "objectID": "json-with-r.html#listen-oder-arrays",
    "href": "json-with-r.html#listen-oder-arrays",
    "title": "7  JSON",
    "section": "7.2 Listen oder Arrays",
    "text": "7.2 Listen oder Arrays"
  },
  {
    "objectID": "case-rewe.html",
    "href": "case-rewe.html",
    "title": "Fall: REWE",
    "section": "",
    "text": "Wie stellen wir Größenverhältnisse (Proportionen) effektiv dar?"
  },
  {
    "objectID": "case-rewe.html#daten",
    "href": "case-rewe.html#daten",
    "title": "Fall: REWE",
    "section": "Daten",
    "text": "Daten"
  },
  {
    "objectID": "case-rewe.html#datensatz",
    "href": "case-rewe.html#datensatz",
    "title": "Fall: REWE",
    "section": "Datensatz",
    "text": "Datensatz\nDer Datensatz besteht aus einem Snapshot aus dem März 2018 aller im REWE Online-Shop angebotenen Produkte.\n\n\n\n\n\n\nWas ist ein Snapshot?\n\n\n\nEin Snapshot ist der Stand eines Datensatzes zu einem bestimmten Zeitpunkt in der Vergangenheit. In diesem Fall wurden die Daten an einem besitmmten Tag aus dem REWE Online-Shop abgegriffen und gespeichert. Die Daten auf der Webseite können sich seitdem verändert haben. Der Datensatz reflektiert diese Änderungen nicht, er bleibt auf dem Stand der Erstellung."
  },
  {
    "objectID": "long-wide-data.html",
    "href": "long-wide-data.html",
    "title": "10  Lange und breite Daten",
    "section": "",
    "text": "Wie bereits in Abschnitt Fall 2: Covid gesehen, können Daten in unterschiedlicher Form vorliegen."
  },
  {
    "objectID": "case-campusbier.html",
    "href": "case-campusbier.html",
    "title": "Fall: Campusbier",
    "section": "",
    "text": "Die Campusbier-Fallstudie ist in dem Sinne eine besondere Fallstudie im Rahmen dieses Buches, als dass sie als Einführung in das Basishandwerkszeug mit R dient. Wenn die Zeit für nur eine Fallstudie ausreicht und man Anfänger mit der Datenanalyse mit R ist, dann ist diese Fallstudie die richtige. Sie steht deshalb auch am Anfang des Buches und dient in allen meinen Modulen zur Datenanalyse mit R als Gegenstand der Einführung.\nDas Campusbier-Projekt beschäftigt sich mit der Vermarktung des hochschuleigenen Bieres, das 2009 von Studierenden auf der Versuchsbrauanlage der Hochschule Osnabrück entwickelt wurde. Im Jahr 2019 wurde das Bier erstmals in größerer Menge gebraut und in Flaschen abgefüllt, so dass es der Osnabrücker Bevölkerung zugänglich gemacht werden konnte. Zuvor war das Bier nur intern in Fässern erhältlich, die etwa für Veranstaltungen am Campus der Hochschule verwendet wurden. Die erste öffentliche Verkaufsrunde im Mai/Juni 2019 war ein voller Erfolg, was zu einer dauerhaften Verfügbarkeit des Bieres über den Onlie-Shop campusbier.de führte. Seitdem sind in vielen Projekten weitere Aktionen und Produkte hinzugekommen, deren Verkäufe sich im vorliegenden Datensatz wiederspiegeln."
  },
  {
    "objectID": "case-campusbier.html#der-datensatz",
    "href": "case-campusbier.html#der-datensatz",
    "title": "Fall: Campusbier",
    "section": "Der Datensatz",
    "text": "Der Datensatz\nDer Datensatz besteht aus den Informationen zu den knapp 3000 Bestellungen, die in den Jahren 2019 bis 2022 über den Online-Shop aufgegeben wurden. Neben den Metadaten einer Bestellung, wie der Bestellzeitpunkt, der Kunde oder die Zahlungsart, gibt es auch die Informationen über die gekauften Produkte, also den Warenkorb jeder Bestellung. Diese Daten liegen als CSV-Exporte aus dem E-Commerce-System Shopify vor. Der Datensatz besteht aus den beiden Dateien orders.csv und line_items.csv. Um dem Datenschutz Rechnung zu tragen, wurden sämtliche persönliche Daten der Kunden entfernt. Jeder Kunde ist nur über eine technische Nummer identifizierbar, die in jeder Bestellung angegeben ist. Haben mehrere Bestellungen die gleiche Kundennummer, so stammen diese alle vom selben Kunden.\n\n\n\n\n\n\nLadet euch am besten jetzt die beiden Dateien in euer Arbeitsverzeichnis herunter. Hier die Links zum Download (rechte Maustaste, “Link speichern unter”):\n\norders.csv\nline_items.csv"
  }
]